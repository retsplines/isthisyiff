import os
import sys
import logging
import uuid
import json
import boto3
import random

# Set up the logging subsystem
logger = logging.getLogger()
logger.setLevel(logging.INFO)
stdout_handler = logging.StreamHandler(sys.stderr)
stdout_handler.setFormatter(logging.Formatter('%(levelname)s: %(message)s'))
logger.addHandler(stdout_handler)

# Define the DynamoDB Table Name
TABLE_NAME = "isthisyiff"
TABLE_REGION = "eu-west-1"

# Define the resource root
RESOURCE_CROP_ROOT_URL = 'https://source-images.isthisyiff.net/crop/'
RESOURCE_ORIG_ROOT_URL = 'https://source-images.isthisyiff.net/'

# Define e621 URL for source links
E621_POST_URL = 'https://e621.net/posts/'

# Define report reasons
REPORT_REASONS = ['wrong_rating', 'copyright', 'unsuitable']

# Define whether to use local images or hotlink them from e621
HOTLINK_IMAGES = os.getenv("HOTLINK_IMAGES", 'False').lower() in ('true', '1', 't')

# The cutoff after which sample-size images are generated by e621
# Only used when HOTLINK_IMAGES is on
E621_SAMPLE_IF_WIDTH_GT = 850

# The URL under which original images are based at e621
# Only used when HOTLINK_IMAGES is on
E621_ORIGINALS_URL = 'https://static1.e621.net/data/'

# Define the SNS topic for reports
REPORTS_SNS_ARN = os.environ.get('REPORTS_SNS_ARN', None)

# Define the maximum number of previews that can be requested in one batch
MAX_PREVIEWS = 250

# Creating the DynamoDB Client
dynamodb_client = boto3.client('dynamodb', region_name=TABLE_REGION)

# Create an SNS client
sns_client = boto3.client('sns')

def get_query_string_param(event, param, default=None):
    """
    Get a query string parameter safely.
    """
    if 'queryStringParameters' not in event or event['queryStringParameters'] is None:
        return default
    
    if param not in event['queryStringParameters']:
        return default
        
    return event['queryStringParameters'][param]

def get_path_param(event, param, default=None):
    """
    Get a path parameter safely.
    """
    return event['pathParameters'][param] if event['pathParameters'] and event['pathParameters'][param] else default

# Generate an original URL
def get_orig_url(post):
    """
    Generate an original URL
    """
    if HOTLINK_IMAGES == True:
        
        # If the image width is > E621_SAMPLE_IF_WIDTH_GT, a sample will exist
        use_sample_size = (int(post['orig_width']['N']) > E621_SAMPLE_IF_WIDTH_GT)
        image_path = '%s%s/%s/%s' % (
            'sample/' if use_sample_size else '',
            post['orig']['S'][0:2],
            post['orig']['S'][2:4],
            # Always a .jpg if sample size being used
            (os.path.splitext(post['orig']['S'])[0] + '.jpg') if use_sample_size else post['orig']['S']
        )
        return E621_ORIGINALS_URL + image_path
    
    return RESOURCE_ORIG_ROOT_URL + post['orig']['S']

def get_random_post(attempts=5):
    """
    Return a random post.
    """
    for attempt in range(attempts):
        try:
            response = dynamodb_client.scan(
                TableName=TABLE_NAME,
                Limit=1,
                ExclusiveStartKey={
                    'uuid': {'S': str(uuid.uuid4())}
                }
            )
            return response['Items'][0]
        except Exception as e:
            logging.warn('get_random_post() attempt %d failed: %s' % (attempt, e))

    raise Exception('Failed to retrieve a random post after %d attempts' % attempts)

def get_post(post_uuid):
    """
    Return a post by UUID.
    """
    response = dynamodb_client.get_item(
        TableName=TABLE_NAME,
        Key={
            'uuid': {'S': post_uuid}
        }
    )
    
    if not response or 'Item' not in response:
        raise Exception('Could not find a post with UUID %s' % post_uuid)
        
    return response['Item']

def get_previews(upto=1, start_from=None, attempts=5):
    """
    Get a number of previews, starting optionally starting from a given UUID
    """
    if start_from is None:
        start_from = str(uuid.uuid4())

    for attempt in range(attempts):
        try:
            response = dynamodb_client.scan(
                TableName=TABLE_NAME,
                Limit=upto,
                ExclusiveStartKey={
                    'uuid': {'S': start_from}
                }
            )
            return response['Items']
        except Exception as e:
            logging.warn('get_previews() attempt %d failed: %s' % (attempt, e))
            # Also, now use a random UUID instead of the original start_from
            start_from = str(uuid.uuid4())
    
    raise Exception('Failed to scan for previews starting with %s upto %d' % (start_from, upto))

def increment_post_counter(post_uuid, was_correct):
    """
    Increment counters on a post.
    """
    dynamodb_client.update_item(
        TableName=TABLE_NAME,
        Key={
            'uuid': {'S': post_uuid}
        },
        UpdateExpression=("ADD %s :inc" % ('correct_guesses' if was_correct else 'incorrect_guesses')),
        ExpressionAttributeValues={
            ":inc": {'N': "1"}
        }
    )
    
def increment_report_reason_count(post, reason):
    """
    Increment a report reason counter.
    """
    
    # Suitable reason?
    if reason not in REPORT_REASONS:
        raise Exception('Invalid report reason. Options are %s' % (','.join(REPORT_REASONS)))
    
    # DynamoDB console shortcut URLs
    dynamo_query_url = 'https://eu-west-1.console.aws.amazon.com/dynamodbv2/home?region=%s#item-explorer?maximize=true&operation=QUERY&pk=%s&table=%s' % (
        TABLE_REGION,
        post['uuid']['S'],
        TABLE_NAME
    )

    # Publish a notification
    sns_client.publish(
        TargetArn=REPORTS_SNS_ARN,
        Message=json.dumps({
            'default': json.dumps({
                'uuid': post['uuid']['S'],
                'reason': reason
            }),
            'email': 'A user reported a post for reason: ' + reason + '\r\n\r\n' + \
                'The post is rated: ' + post['rating']['S'] + '\r\n' + \
                'View: https://isthisyiff.net/#' + post['uuid']['S'] + '\r\n' + \
                'View image on e621: ' + get_orig_url(post) + '\r\n' + \
                'View post on e621: ' + E621_POST_URL + str(post['id']['N']) + '\r\n' + \
                'View in DynamoDB: ' + dynamo_query_url
        }),
        MessageStructure='json',
        Subject='Reported content on IsThisYiff: ' + post['uuid']['S'] + ' (' + reason + ')'
    )
    
    dynamodb_client.update_item(
        TableName=TABLE_NAME,
        Key={
            'uuid': {'S': post['uuid']['S']}
        },
        UpdateExpression=("ADD %s :inc" % ('reports_' + reason)),
        ExpressionAttributeValues={
            ":inc": {'N': "1"}
        }
    )
    
def build_json_response(content, status=200):
    """
    Build and return a response object.
    """
    return {
        "statusCode": status,
        "body": json.dumps(content),
        "headers": {
            "Content-Type": "application/json",
            "X-UwU-or-OwO": random.choice(['UwU', 'OwO'])
        }
    }

def route_post_report_challenge(event, context):
    """
    POST /challenge/{post_uuid}/report/{reason}
    """
    post_uuid = event['pathParameters']['post_uuid']
    reason = event['pathParameters']['reason']
    
    # Find the post to ensure it exists
    post = get_post(post_uuid)
    
    # Update the post
    increment_report_reason_count(post, reason)
    return build_json_response({})
    
def route_get_challenge(event, context):
    """
    GET /challenge
    Gets a new challenge.
    """
    
    post_uuid = get_path_param(event, 'post_uuid')
    post = get_post(post_uuid) if post_uuid is not None else get_random_post()
        
    stripped_post = {
        'uuid': post['uuid']['S'],
        'crop': {
            'url': RESOURCE_CROP_ROOT_URL + post['crop']['S'],
            'width': int(post['crop_width']['N']),
            'height': int(post['crop_height']['N'])
        }
    }
    return build_json_response(stripped_post)
    
def route_get_previews(event, context):
    """
    GET /preview
    Gets a number of preview crops.
    """
    
    start_from = get_query_string_param(event, 'from')
    upto = int(get_query_string_param(event, 'upto', 1))
    
    # Restrict the number of previews that can be requested
    if upto > MAX_PREVIEWS:
        upto = MAX_PREVIEWS

    # Get previews
    preview_list = get_previews(upto, start_from)
    previews = {
        'previews': list(map(lambda preview: {
            'crop': {
                'url': RESOURCE_CROP_ROOT_URL + preview['crop']['S'],
                'width': int(preview['crop_width']['N']),
                'height': int(preview['crop_height']['N'])
            },
            'uuid': str(preview['uuid']['S'])
        }, preview_list))
    }

    return build_json_response(previews)

def route_post_challenge(event, context):
    """
    POST /challenge/{post_uuid}/{guess}
    Checks the response to a challenge.
    """
    post_uuid = event['pathParameters']['post_uuid']
    guess = event['pathParameters']['guess']
    
    # Valid guess?
    if guess not in ['s', 'e']:
        raise Exception('Challenge guesses must be either "s" or "e"')
    
    # Find the post with this UUID
    post = get_post(post_uuid)
    
    # Correct?
    correct = post['rating']['S'] == guess
    
    # Increment the appropriate counter
    increment_post_counter(post_uuid, correct)
    
    result = {
        'uuid': post['uuid']['S'],
        'source': {
            'id': int(post['id']['N']),
            'url': E621_POST_URL + str(post['id']['N']),
            'fav_count': int(post['fav_count']['N']),
            'score': int(post['score']['N'])
        },
        'result': {
            'actual': post['rating']['S'],
            'guess': guess
        },
        'orig': {
            'url': get_orig_url(post),
            'width': int(post['orig_width']['N']),
            'height': int(post['orig_height']['N'])
        },
        'crop': {
            'url': RESOURCE_CROP_ROOT_URL + post['crop']['S'],
            'width': int(post['crop_width']['N']),
            'height': int(post['crop_height']['N']),
            'position': {
                'left': int(post['crop_left']['N']),
                'top': int(post['crop_top']['N'])
            }
        },
        'statistics': {
            'correct_guesses': int(post['correct_guesses']['N']) + (1 if correct else 0),
            'incorrect_guesses': int(post['incorrect_guesses']['N']) + (0 if correct else 1)
        }
    }
    
    return build_json_response(result)

def lambda_handler(event, context):
    """
    Handle an HTTP request.
    """
    
    logger.info('%s %s' % (event['httpMethod'], (event['path'])))
    print(event)
    
    routes = {
        'GET /preview': route_get_previews,
        'GET /challenge': route_get_challenge,
        'GET /challenge/{post_uuid}': route_get_challenge,
        'POST /challenge/{post_uuid}/{guess}': route_post_challenge,
        'POST /challenge/{post_uuid}/report/{reason}': route_post_report_challenge
    }
    
    # Route the request
    resource_name = event['requestContext']['resourceId']
    
    # Handle errors that occur during dispatch
    try:

        # Dispatch to the appropriate route
        if resource_name in routes:
            return routes[resource_name](event, context)
        else:
            return build_json_response({
                'error': 'uwu 404 not found sorry hehe'
            }, 404)
        
    except Exception as e: 
        return build_json_response({
            'folf': 'sad :(',
            'error': str(e)
        }, 500)

